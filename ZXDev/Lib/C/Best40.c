/*
;----------------------------------------------------------------;
;                40 New Best Routines (graphic)                  ;
;          (c) SerzhSoft, Shadrinsk, may-june, 1997              ;
;    old length: 1444 bytes         new length:  861 bytes       ;
;----------------------------------------------------------------;
; http://vladik1232008.narod.ru/ZX_FORUM_40_Best_procedures.html ;
;           Adapted to ZXDev/SDCC by Oleg N. Cher, 2012          ;
;----------------------------------------------------------------;
*/

void Best40_ASRL_LF (unsigned char atr) __z88dk_fastcall;
void Best40_ASRL_RG (unsigned char atr) __z88dk_fastcall;
void Best40_ASRL_UP (unsigned char atr) __z88dk_fastcall;
void Best40_ASRL_DN (unsigned char atr) __z88dk_fastcall;
void Best40_SSRL_LF (void);
void Best40_SSRL_RG (void);
void Best40_SSRL_UP (void);
void Best40_SSRL_DN (void);
void Best40_PSRL_LF (void);
void Best40_PSRL_RG (void);
void Best40_PSRL_UP (void);
void Best40_PSRL_DN (void);
void Best40_SCR_MRG (unsigned int scr_addr) __z88dk_fastcall;
void Best40_SCR_INV (void);
void Best40_SINV_UD (unsigned int char_addr) __z88dk_fastcall;
void Best40_SINV_LR (unsigned int char_addr) __z88dk_fastcall;
void Best40_SROTATE (unsigned int char_addr) __z88dk_fastcall;
void Best40_ACHANGE (unsigned char attr_and, unsigned char attr_or) __z88dk_callee;
void Best40_AREPLC (unsigned char attr_from, unsigned char attr_to) __z88dk_callee;
void Best40_PAINT (unsigned char x, unsigned char y) __z88dk_callee;
unsigned char Best40_POINT (unsigned char x, unsigned char y) __z88dk_callee;
void Best40_PFIGURE (unsigned char x, unsigned char y, unsigned char *pattern);
void Best40_PSCALER (unsigned char x1_old, unsigned char y1_old,
  unsigned char x2_old, unsigned char y2_old, unsigned char xscale,
  unsigned char yscale, unsigned char x_new, unsigned char y_new);
void Best40_PUTSPR (
  unsigned char x, unsigned char y, unsigned char len, unsigned char hgt,
  unsigned int adr, unsigned char mode) __z88dk_callee;
void Best40_SCREEN_APART (unsigned char steps) __z88dk_fastcall;
void Best40_PRSTR_AT_E (unsigned char x, unsigned char y, unsigned char *str) __z88dk_callee;
void Best40_FILLED_CIRCLE (unsigned char x, unsigned char y, unsigned char radius) __z88dk_callee;

/*================================== Header ==================================*/

// Сдвиг атрибутов влево (22<=23)

void Best40_ASRL_LF (unsigned char atr) __z88dk_fastcall {
__asm
          LD      DE,#0x5800   // DE=адрес первого байта атрибутов
LP_ASLF$: LD      A,L          // цвет заполнения после сдвига
          LD      H,D          // скопировали DE в HL
          LD      L,E          //  и увеличили HL на единицу:
          INC     HL           //  HL=адрес второго байта атрибутов
          LD      BC,#0x001F   // <длина линии атрибутов> - 1
          LDIR                 // сдвиг линии атрибутов влево
          LD      (DE),A       // устанавливаем новый атрибут
          LD      L,A
          INC     DE           // переход к следующей линии снизу
          LD      A,D          // если атрибуты уже кончились,
          CP      #0x5B        //  и мы набрели на буфер принтера,
          JR      C,LP_ASLF$   //  то STOP, иначе сдвигаем дальше
__endasm;
} //Best40_ASRL_LF

/*--------------------------------- Cut here ---------------------------------*/

// Сдвиг атрибутов вправо (21<=23)

void Best40_ASRL_RG (unsigned char atr) __z88dk_fastcall {
__asm
          LD      A,L          // цвет заполнения после сдвига
          LD      DE,#0x5AFF   // адрес последнего байта атрибутов
LP_ASRG$: LD      H,D          // скопировали DE в HL -
          LD      L,E          //  последний байт линии атрибутов
          DEC     HL           // предпоследний байт линии атрибутов
          LD      BC,#0x001F   // <длина линии атрибутов> - 1
          LDDR                 // сдвиг линии атрибутов вправо
          LD      (DE),A       // устанавливаем новый атрибут
          DEC     DE           // переход к следующей линии сверху
          BIT     3,D          // если мы всё ещё в атрибутах,
          JR      NZ,LP_ASRG$  //  то повторяем цикл для сл. линии
__endasm;
} //Best40_ASRL_RG

/*--------------------------------- Cut here ---------------------------------*/

// Сдвиг атрибутов вверх (19<=21)

void Best40_ASRL_UP (unsigned char atr) __z88dk_fastcall {
__asm
          LD      A,L          // цвет для заполнения нижней линии
          LD      HL,#0x5820   // адрес второй линии атрибутов
          LD      DE,#0x5800   // адрес первой линии атрибутов
          LD      BC,#0x02E0   // перемещать: 23 линии по 32 байта
          LDIR                 // сдвигаем 23 нижние линии вверх
LP_ASUP$: LD      (DE),A       // устанавливаем новый атрибут
          INC     E            // если заполнили всю последнюю линию
          JR      NZ,LP_ASUP$  //  (E=0), то прерываем цикл
__endasm;
} //Best40_ASRL_UP

/*--------------------------------- Cut here ---------------------------------*/

// Сдвиг атрибутов вниз (20<=21)

void Best40_ASRL_DN (unsigned char atr) __z88dk_fastcall {
__asm
          LD      A,L          // цвет для заполнения верхней линии
          LD      HL,#0x5ADF   // адрес конца второй линии снизу
          LD      DE,#0x5AFF   // адрес конца самой нижней линии
          LD      BC,#0x02E0   // перемещать: 23 линии по 32 байта
          LDDR                 // сдвигаем 23 верхние линии вниз
LP_ASDN$: LD      (DE),A       // устанавливаем новый атрибут
          DEC     E            // если дошли до самого первого байта
          JR      NZ,LP_ASDN$  //  области атрибутов (E=0), то STOP
          LD      (DE),A       //  и устанавливаем этот байт
__endasm;
} //Best40_ASRL_DN

/*--------------------------------- Cut here ---------------------------------*/

// Сдвиг влево на один символ (20<=21)

void Best40_SSRL_LF (void) {
__asm
          LD      DE,#0x4000   // начало области графики
LP_SSLF$: LD      H,D          // адрес первого
          LD      L,E          //  байта линии
          INC     HL           // адрес второго байта линии
          LD      BC,#0x001F   // сколько байт сдвигать
          LDIR                 // сдвиг линии влево на 1 байт
          XOR     A            // обнулили аккумулятор и занесли
          LD      (DE),A       //  в последний (правый) байт линии
          INC     DE           // переход к следующей линии (снизу)
          LD      A,D          // если атрибуты
          CP      #0x58        //  "ещё не видать",
          JR      C,LP_SSLF$   //  то повторяем цикл для сл. линии
__endasm;
} //Best40_SSRL_LF

/*--------------------------------- Cut here ---------------------------------*/

// Сдвиг вправо на один символ (19<=22)

void Best40_SSRL_RG (void) {
__asm
          LD      DE,#0x57FF   // последний байт области графики
LP_SSRG$: LD      H,D          // адрес последнего байта
          LD      L,E          //  текущей линии
          DEC     HL           // адрес предпоследнего байта
          LD      BC,#0x001F   // сдвигаем: 31 байт
          LDDR                 // сдвиг линии графики вправо
          XOR     A            // очищаем аккумулятор и затем
          LD      (DE),A       //  первый (левый) байт текущей линии
          DEC     DE           // переход к следующей линии выше
          BIT     6,D          // если мы ещё не "набрели" на ПЗУ,
          JR      NZ,LP_SSRG$  //  то продолжаем крутить цикл
__endasm;
} //Best40_SSRL_RG

/*--------------------------------- Cut here ---------------------------------*/

// Сдвиг вверх на один символ (55<=68)

void Best40_SSRL_UP (void) {
__asm
          LD      DE,#0x4000   // начало экранной области
LP_SSU1$: PUSH    DE           // сохраняем адрес линии на стеке
          LD      BC,#0x0020   // в линии - 32 байта
          LD      A,E          // В регистре DE находится адрес
          ADD     A,C          //  верхней линии. В регистре
          LD      L,A          //  HL необходимо получить адрес
          LD      A,D          //  линии, лежащей ниже с шагом 8.
          JR      NC,GO_SSUP$  //  Для этого к регистру E прибав-
          ADD     A,#0x08      //  ляем 32 и заносим в L. Если про-
GO_SSUP$: LD      H,A          //  изошло переполнение, то H=D+8
          LDIR                 // перенос одной линии (32 байта)
          POP     DE           // восстанавливаем адрес начала линии
          LD      A,H          // проверяем: а не пора ли нам закру-
          CP      #0x58        //  гляться? (перенесли все 23 ряда)
          JR      NC,LP_SSU2$  // если да, то переход на очистку
          INC     D            // ---------------------------------;
          LD      A,D          //              DOWN_DE
          AND     #0x07        //  стандартная последовательность
          JR      NZ,LP_SSU1$  //   команд для перехода на линию
          LD      A,E          //      вниз в экранной области
          ADD     A,#0x20      //         (для регистра DE)
          LD      E,A          //
          JR      C,LP_SSU1$   //  на входе:  DE - адрес линии
          LD      A,D          //  на выходе: DE - адрес линии ниже
          SUB     #0x08        //   используется аккумулятор
          LD      D,A          //
          JR      LP_SSU1$     // ---------------------------------;
LP_SSU2$: XOR     A            // очистка аккумулятора
LP_SSU3$: LD      (DE),A       // и с его помощью -
          INC     E            //  очистка одной линии изображения
          JR      NZ,LP_SSU3$  //  всего: 32 байта
          LD      E,#0xE0      // переход к следующей
          INC     D            //  (нижней) линии изображения
          BIT     3,D          // заполнили весь последний ряд?
          JR      Z,LP_SSU2$   // если нет, то продолжаем заполнять
__endasm;
} //Best40_SSRL_UP

/*--------------------------------- Cut here ---------------------------------*/

// Сдвиг вниз на один символ (55<=73)

void Best40_SSRL_DN (void) {
__asm
          LD      DE,#0x57FF   // адрес последнего байта графики
LP_SSD1$: PUSH    DE           // сохранили адрес конца линии
          LD      BC,#0x0020   // длина одной линии изображения
          LD      A,E          // в регистре HL
          SUB     C            //  получаем адрес
          LD      L,A          //  конца линии,
          LD      A,D          //  лежащей выше
          JR      NC,GO_SSDN$  //  исходной с шагом
          SUB     #0x08        //  в 8 пикселей (линий):
GO_SSDN$: LD      H,A          //  HL=откуда копировать; DE=куда
          LDDR                 // перенос одной линии графики
          POP     DE           // восстанавливаем адрес конца линии
          BIT     6,H          // если мы уже не в экране,
          JR      Z,LP_SSD2$   //  то переходим на очистку
          LD      A,D          // ---------------------------------;
          DEC     D            //               UP_DE
          AND     #0x07        //  стандартная последовательность
          JR      NZ,LP_SSD1$  //   команд для перехода на линию
          LD      A,E          //     вверх в экранной области
          SUB     #0x20        //         (для регистра DE)
          LD      E,A          //
          JR      C,LP_SSD1$   //  на входе:  DE - адрес линии
          LD      A,D          //  на выходе: DE - адрес линии выше
          ADD     A,#0x08      //   используется аккумулятор
          LD      D,A          //
          JR      LP_SSD1$     // ---------------------------------;
LP_SSD2$: XOR     A            // очистка аккумулятора
LP_SSD3$: LD      (DE),A       // очистка одной
          DEC     E            //  линии изображения:
          JR      NZ,LP_SSD3$  //  (31 байт)
          LD      (DE),A       // очищаем самый первый байт линии
          LD      E,#0x1F      // переход к следующей (верхней)
          DEC     D            //  линии ряда из восьми линий
          BIT     6,D          // мы ещё не попали в ПЗУ?
          JR      NZ,LP_SSD2$  // если нет, то очищаем дальше
__endasm;
} //Best40_SSRL_DN

/*--------------------------------- Cut here ---------------------------------*/

// Сдвиг влево на один пиксел (16<=17)

void Best40_PSRL_LF (void) {
__asm
          LD      HL,#0x57FF   // адрес последнего байта графики
LP_PSL1$: OR      A            // сбрасываем флаг переноса CF
          LD      B,#0x20      // в одной линии - 32 байта
LP_PSL2$: RL      (HL)         // CF<-[сдвигаемый байт]<-CF (влево)
          DEC     HL           // переход к предыдущему байту линии
          DJNZ    LP_PSL2$     // цикл сдвига для одной линии
          BIT     6,H          // мы ещё в экране?
          JR      NZ,LP_PSL1$  // если да, то сдвигаем след. линию
__endasm;
} //Best40_PSRL_LF

/*--------------------------------- Cut here ---------------------------------*/

// Сдвиг вправо на один пиксел (17)

void Best40_PSRL_RG (void) {
__asm
          LD      HL,#0x4000   // адрес первого байта графики
          LD      C,#0xC0      // сдвигать - 192 линии
LP_PSR1$: OR      A            // CF=0 для пустой колонки слева
          LD      B,#0x20      // число байт в одной линии
LP_PSR2$: RR      (HL)         // сдвиг одного байта вправо
          INC     HL           // следующий байт линии изображения
          DJNZ    LP_PSR2$     // сдвигаем всю линию - 32 байта
          DEC     C            // уменьшаем счетчик линий
          JR      NZ,LP_PSR1$  // если сдвинули все линии, то STOP
__endasm;
} //Best40_PSRL_RG

/*--------------------------------- Cut here ---------------------------------*/

// Сдвиг вверх на один пиксел (38<=91)

void Best40_PSRL_UP (void) {
__asm
          LD      DE,#0x4000   // адрес начала графики (верх. линия)
LP_PSU1$: LD      H,D          // скопировали адрес начала
          LD      L,E          //  линии графики в HL
          LD      BC,#0x0020   // размер одной линии
          INC     H            // ---------------------------------;
          LD      A,H          //             DOWN_HL
          AND     #0x07        //  стандартная последовательность
          JR      NZ,GO_PSUP$  //   команд для перехода на линию
          LD      A,L          //      вниз в экранной области
          ADD     A,C          //         (для регистра HL)
          LD      L,A          //  (здесь ADD A,C вместо ADD A,#08)
          JR      C,GO_PSUP$   //  на входе:  HL - адрес линии
          LD      A,H          //  на выходе: HL - адрес линии ниже
          SUB     #0x08        //   используется аккумулятор
          LD      H,A          // ---------------------------------;
GO_PSUP$: PUSH    HL           // сохраняем адрес нижней линии
          LDIR                 // переброска изображения снизу-вверх
          POP     DE           // DE - адрес нижней линии
          LD      A,H          // мы ещё находимся в области графики
          CP      #0x58        //  или уже наткнулись на атрибуты?
          JR      C,LP_PSU1$   // если всё ещё графика, то повтор
          XOR     A            // обнуляем аккумулятор и с его
LP_PSU2$: LD      (DE),A       //  помощью очищаем самую
          INC     E            //  нижнюю линию изображения
          JR      NZ,LP_PSU2$  //  после сдвига экрана вверх
__endasm;
} //Best40_PSRL_UP

/*--------------------------------- Cut here ---------------------------------*/

// Сдвиг вниз на один пиксел (38<=90)

void Best40_PSRL_DN (void) {
__asm
          LD      DE,#0x57FF   // адрес последнего байта графики
LP_PSD1$: LD      H,D          // скопировали адрес последнего
          LD      L,E          //  байта линии в HL
          LD      BC,#0x0020   // ширина одной линии изображения
          LD      A,H          // ---------------------------------;
          DEC     H            //               UP_HL
          AND     #0x07        //  стандартная последовательность
          JR      NZ,GO_PSDN$  //   команд для перехода на линию
          LD      A,L          //     вверх в экранной области
          SUB     C            //         (для регистра HL)
          LD      L,A          //    (здесь SUB C вместо SUB #08)
          JR      C,GO_PSDN$   //  на входе:  HL - адрес линии
          LD      A,H          //  на выходе: HL - адрес линии выше
          ADD     A,#0x08      //   используется аккумулятор
          LD      H,A          // ---------------------------------;
GO_PSDN$: PUSH    HL           // сохраняем адрес верхней линии
          LDDR                 // переносим 1 линию сверху - вниз
          POP     DE           // адрес верхней линии стал текущим
          BIT     6,H          // пока ещё не попали в ПЗУ -
          JR      NZ,LP_PSD1$  //  продолжаем цикл по линиям
          XOR     A            // очищаем аккумулятор и с его
LP_PSD2$: LD      (DE),A       //  помощью - самую верхнюю линию
          DEC     E            //  изображения после сдвига
          JR      NZ,LP_PSD2$  //  всего экрана вниз
          LD      (DE),A       // очистка самого первого байта
__endasm;
} //Best40_PSRL_DN

/*--------------------------------- Cut here ---------------------------------*/

// Слияние картинок (17<=21)

void Best40_SCR_MRG (unsigned int scr_addr) __naked __z88dk_fastcall {
__asm
          LD      DE,#0x4000   // адрес экранной области
LP_SCRM$: LD      A,(DE)       // байт изображения с экрана
          OR      (HL)         // "слили" с байтом картинки в памяти
          LD      (DE),A       // и поместили назад в экран
          INC     HL           // следующий байт картинки в памяти
          INC     DE           // следующий байт экранной области
          LD      A,D          // проверка на окончание
          CP      #0x58        //  экранной области
          JR      C,LP_SCRM$   // если не кончилась, то повторяем
          RET
__endasm;
} //Best40_SCR_MRG

/*--------------------------------- Cut here ---------------------------------*/

// Инвертирование экрана (12<=18)

void Best40_SCR_INV (void) {

__asm
          LD      HL,#0x57FF   // последний байт экранной области
LP_SCRI$: LD      A,(HL)       // взяли байт изображения с экрана
          CPL                  // проинвертировали его
          LD      (HL),A       // и поставили обратно
          DEC     HL           // двигаемся к началу области
          BIT     6,H          // если "перевалили" через начало,
          JR      NZ,LP_SCRI$  //  то STOP, иначе крутим цикл
__endasm;
} //Best40_SCR_INV

/*--------------------------------- Cut here ---------------------------------*/

// Инвертирование символа вертикально (20)

void Best40_SINV_UD (unsigned int char_addr) __naked __z88dk_fastcall {
__asm
          LD      D,H          // сохранили этот
          LD      E,L          //  адрес в DE
          LD      B,#0x08      // в символе - 8 байт
LP_SIU1$: LD      A,(HL)       // берём один байт символа
          PUSH    AF           // и заталкиваем на стек
          INC     HL           // переход к следующему байту символа
          DJNZ    LP_SIU1$     // повторяем цикл для восьми байт
          LD      B,#0x08      // сколько байт будем считывать
LP_SIU2$: POP     AF           // извлекаем байт со стека и в обрат-
          LD      (DE),A       //  ном порядке записываем в символ
          INC     DE           // следующий байт символа
          DJNZ    LP_SIU2$     // крутим цикл восемь раз
          RET
__endasm;
} //Best40_SINV_UD

/*--------------------------------- Cut here ---------------------------------*/

// Инвертирование символа горизонтально (17<=19)

void Best40_SINV_LR (unsigned int char_addr) __naked __z88dk_fastcall {
__asm
          LD      B,#0x08      // модифицируем: 8 байт
LP_SIL1$: LD      A,#0x01      // устанавливаем нулевой бит A в 1
LP_SIL2$: RR      (HL)         // вращаем байт символа вправо
          RLA                  // а аккумулятор - влево (через CF)
          JR      NC,LP_SIL2$  // пока нулевой бит не окажется в CF
          LD      (HL),A       // записываем измененный байт
          INC     HL           // следующий байт символа
          DJNZ    LP_SIL1$     // повторяем цикл 8 раз
          RET
__endasm;
} //Best40_SINV_LR

/*--------------------------------- Cut here ---------------------------------*/

// Вращение символа по часовой стрелке (26<=42)

void Best40_SROTATE (unsigned int char_addr) __naked __z88dk_fastcall {
__asm
          LD      B,#0x08      // 8 вертикальных колонок в символе
LP_SRO1$: PUSH    HL           // сохранили адрес на стеке
          LD      A,#0x80      // включили 7-ой бит в аккумуляторе
LP_SRO2$: RR      (HL)         // вращаем байты символа вправо
          RRA                  //  и по одному биту из каждого байта
          INC     HL           //  постепенно заполняем аккумулятор
          JR      NC,LP_SRO2$  //  пока 7 вкл. бит не попадет в CF
          POP     HL           // восстанавливаем адрес символа
          PUSH    AF           // вертик. колонку символа - на стек
          DJNZ    LP_SRO1$     // крутим цикл по числу колонок
          LD      B,#0x08      // колонки стали линиями - байтами
LP_SRO3$: POP     AF           // стаскиваем байт со стека
          LD      (HL),A       // и это - уже новая линия символа
          INC     HL           // следующий байт символа
          DJNZ    LP_SRO3$     // повторяем по числу линий (8 байт)
          RET
__endasm;
} //Best40_SROTATE

/*--------------------------------- Cut here ---------------------------------*/

// Изменение атрибута (16<=21)

void Best40_ACHANGE (unsigned char attr_and, unsigned char attr_or) __naked __z88dk_callee {
__asm
          POP     HL           // C - маска битов для операции AND
          POP     BC           // B - маска битов для операции OR
          LD      DE,#0x5AFF   // последний байт области атрибутов
LP_ACHN$: LD      A,(DE)       // взяли текущее значение атрибута
          AND     C            // отбросили лишние биты
          OR      B            // добавили необходимые
          LD      (DE),A       // и записали на старое место
          DEC     DE           // движемся к началу атрибутов
          BIT     3,D          // а не графика ли уже?
          JR      NZ,LP_ACHN$  // если нет, то крутим цикл
          JP      (HL)
__endasm;
} //Best40_ACHANGE

/*--------------------------------- Cut here ---------------------------------*/

// Смена атрибута (18<=22)

void Best40_AREPLC (unsigned char attr_from, unsigned char attr_to) __naked __z88dk_callee {
__asm
          POP     HL
          POP     DE           // E - что искать
          PUSH    HL           // D - чем заменять
          LD      HL,#0x5AFF   // последний байт области атрибутов
LP_ARPL$: LD      A,(HL)       // взяли байт из области атрибутов
          CP      E            // не тот ли, что ищем?
          JR      NZ,GO_ARPL$  // нет, перепрыгиваем изменение
          LD      (HL),D       // да, изменяем на новое значение
GO_ARPL$: DEC     HL           // движемся к началу обл-ти атрибутов
          BIT     3,H          // атрибуты ещё не кончились?
          JR      NZ,LP_ARPL$  // если нет, то проверяем следующий
          RET
__endasm;
} //Best40_AREPLC

/*--------------------------------- Cut here ---------------------------------*/

// Закрашивание контура (123<=263)
//  123=88+35 - вместе с процедурой POINT

void Best40_PAINT (unsigned char x, unsigned char y) __naked __z88dk_callee {
__asm
          POP     HL           // L = координата X начальной точки
          EX      (SP),HL      // H = координата Y начальной точки
          LD      A,H          // проверяем координату Y на выход
          CP      #0xC0        //  за пределы экрана:
          RET     NC           //  если Y>=192, то экстренный выход
          SBC     A,A          // т.к. CF=1, то SBC A,A даёт A=#FF -
          PUSH    AF           //  это будет указатель конца стека
          PUSH    HL           // запоминаем координаты первой точки
LP_PNT1$: POP     DE           // берём со стека X,Y след. точки
          INC     D            // если Y=#FF, то стек исчерпан,
          RET     Z            //  и тогда выходим из процедуры
          DEC     D            // восстанавливаем исходн. значение Y
          CALL    __POINT__    // проверяем точку с коорд-ми (E,D)
          JR      NZ,LP_PNT1$  // если включена, то переход к след.
          EX      AF,AF        // A'=0, CF=0 - вспомогат. признаки
LP_PNT2$: LD      A,E          // взяли координату X
          OR      A            // если она равна нулю,
          JR      Z,GO_PNT1$   //  то прыжок через движение назад
          DEC     E            // иначе - уменьшаем координату X
          CALL    __POINT__    // и проверяем предыдущую точку
          JR      Z,LP_PNT2$   // если "нет препятствия", повторяем
LP_PNT3$: INC     E            // переход на точку вправо (X=X+1)
          JR      Z,LP_PNT1$   // если X>255, то сл. точка со стека
GO_PNT1$: CALL    __POINT__    // проверяем следующую правую точку
          JR      NZ,LP_PNT1$  // если включена, то след. со стека
          LD      A,(HL)       // если точка не установлена,
          OR      C            //  то берём байт с экрана, включаем
          LD      (HL),A       //  нужный бит и ставим назад
          LD      A,D          // проверяем координату Y:
          OR      A            // если она равна нулю,
          JR      Z,GO_PNT4$   //  то не проверяем лежащ. выше линию
          DEC     D            // переход к линии выше (Y=Y-1)
          CALL    __POINT__    // проверка вышележащей точки
          JR      Z,GO_PNT2$   // если не включена, то переход
          EX      AF,AF        // взяли вспомогательные флаги
          LD      A,B          // разрешили запоминать точку в стеке
          JR      GO_PNT3$     // переход на продолжение
GO_PNT2$: EX      AF,AF        // взяли вспомогательные флаги
          INC     A            // если A>0, то это означает запрет
          DEC     A            //  на сохранение координаты новой
          JR      NZ,GO_PNT3$  //  точки в стеке, -> перепрыгиваем
          LD      A,C          // иначе - запрещаем сохранять коор-
          PUSH    DE           //  динаты, но одну пихаем на стек
GO_PNT3$: EX      AF,AF        // сохранили вспомогательные флаги
          INC     D            // возвращаемся на нижнюю линию
GO_PNT4$: LD      A,D          // проверяем координату Y:
          CP      #0xBF        // если - последняя (ниже не бывает),
          JR      NC,LP_PNT3$  //  то переход к след. точке справа
          INC     D            // иначе - спускаемся на линию ниже
          CALL    __POINT__    // проверяем нижележащую точку
          JR      Z,GO_PNT5$   // если не включена, то переход
          EX      AF,AF        // взяли вспомогательные флаги
          AND     A            // разрешили запоминать точку в стеке
          JR      GO_PNT6$     // переход на продолжение
GO_PNT5$: EX      AF,AF        // взяли вспомогательные флаги
          JR      C,GO_PNT6$   // если нельзя сохранять, то переход
          SCF                  // запрещаем сохранять точку на стеке
          PUSH    DE           // но одну точку на стек запихиваем
GO_PNT6$: EX      AF,AF        // сохранили вспомогательные флаги
          DEC     D            // возвращаемся на верхнюю линию
          JR      LP_PNT3$     // переход к следующей точке справа
__endasm;
} //Best40_PAINT

/*--------------------------------- Cut here ---------------------------------*/

// Проверка состояния точки и вычисление адреса в экране (35<=70)

unsigned char Best40_POINT (unsigned char x, unsigned char y) __naked __z88dk_callee {
__asm
          POP     HL
          POP     DE           // E = координата X; D = координата Y
          PUSH    HL
          CALL    __POINT__    // вызов POINT
          LD      L,A          // результат: 0 (FALSE) или не 0 (TRUE)
          RET
__endasm;
} //Best40_POINT

/*--------------------------------- Cut here ---------------------------------*/

// если точка выключена, то ZF=1 (Z), иначе ZF=0 (NZ)

void _POINT__ (void) {
__asm
          LD      B,#0x07      // часто используемая маска (#07)
          LD      A,D          // взяли Y-координату
          RRA                  // разделили её на 8
          SCF                  //  и начали формировать
          RRA                  //  старший байт
          RRA                  //  адреса пиксела
          AND     #0x5F        //  в экране (регистр H):
          LD      H,A          //   %010yyyyy
          XOR     E            // далее формируем
          AND     B            //  младший байт
          XOR     E            //  адреса
          RRCA                 //  пиксела
          RRCA                 //  в экране
          RRCA                 //  (регистр L):
          LD      L,A          //   %yyyxxxxx
          LD      A,D          // заканчиваем
          XOR     H            //  формирование
          AND     B            //  старшего байта
          XOR     H            //  адреса пиксела
          LD      H,A          //  в экране (регистр H)
          LD      A,E          // начинаем формировать
          AND     B            //  маску пиксела в байте
          LD      B,A          //  изображения (соответствующий
          LD      A,#0x80      //  бит включен). Включаем 7-ой бит
          JR      Z,GO_PNT$    // если это как раз то что надо,
LP_PNT$:  RRCA                 //  то перепрыгиваем через сдвиг
          DJNZ    LP_PNT$      //  включенного бита вправо
GO_PNT$:  LD      C,A          // сохраняем маску вкл. бита в рег. C
          AND     (HL)         // проверяем пиксел в экране
__endasm;
} //_POINT__

/*--------------------------------- Cut here ---------------------------------*/

// Построение шаблонов (98<=196)
//  98+35=133 - вместе с процедурой POINT

void Best40_PFIGURE_E (unsigned char x, unsigned char y, unsigned char *pattern) __naked __z88dk_callee {
__asm
          POP     BC
          POP     DE           // координаты E=X, D=Y начальной точки
          POP     HL           // адрес шаблона pattern в памяти
          PUSH    BC
          DEC     HL           // первый раз адрес остаётся неизменным
LP_PFG3$: INC     HL           //  потом будем прибавлять, переходя к след.симв.
          LD      A,(HL)       // взяли очередной символ данных шаблона
          OR      A            // если достигнут конец (символ с кодом 0)
          RET     Z            //  выходим из процедуры
          CP      #"0"         // а не "поставить ли точку"?
          JR      NZ,GO_PFG6$  // если нет, переход на продолжение
          LD      A,D          // y-координата текущей точки
          CP      #0xC0        // если выходит за нижнюю кромку
          JR      NC,LP_PFG3$  //  экрана, то точку не изображаем
          PUSH    HL           // иначе - сохраняем некоторые
          PUSH    BC           //  регистры, чтоб не портились
          CALL    __POINT__    // вызываем процедуру проверки точки
          LD      A,(HL)       // по вычисленным значениям
          OR      C            //  изображаем точку на экране
          LD      (HL),A       //  пользуясь тем, что HL=адрес,
          POP     BC           //  а регистр C содержит маску точки
          POP     HL           // восстанавливаем сохр-ные регистры
          JR      LP_PFG3$     // обработка след. символа шаблона
GO_PFG6$: SUB     #"5"         // сместить перо влево?
          JR      NZ,GO_PFG7$  // если нет, то оставить всё как есть
          DEC     E            // иначе - уменьшить x-координату
GO_PFG7$: DEC     A            // двигаемся вниз?
          JR      NZ,GO_PFG8$  // нет, переход
          INC     D            // да, увеличиваем y-координату
GO_PFG8$: DEC     A            // направление "вверх"?
          JR      NZ,GO_PFG9$  // нет, перепрыгиваем
          DEC     D            // да, уменьшаем y-координату
GO_PFG9$: DEC     A            // может надо сдвинуться вправо?
          JR      NZ,LP_PFG3$  // нет, переход к след. символу шабл.
          INC     E            // да, увеличиваем x-координату
          JR      LP_PFG3$     //  и переходим к след. символу шабл.
__endasm;
} //Best40_PFIGURE_E

/*--------------------------------- Cut here ---------------------------------*/

// Увеличение экрана и копирование (174<=335)
//  174+35=209 - вместе с процедурой POINT

void Best40_PSCALER (unsigned char x1_old, unsigned char y1_old,
  unsigned char x2_old, unsigned char y2_old, unsigned char xscale,
  unsigned char yscale, unsigned char x_new, unsigned char y_new) __naked {
__asm
          PUSH    IX
          LD      IX,#4
          ADD     IX,SP
          CALL    __PSCALER__
          POP     IX
          RET
__endasm;
} //Best40_PSCALER

/*--------------------------------- Cut here ---------------------------------*/
void _PSCALER__ (void) {
__asm
          LD      L,4(IX)
          LD      H,5(IX)      ;масштабность увеличения по x и y
          INC     L            ;проверка x-координаты
          DEC     L            ; на нулевое значение
          RET     Z            ;если равна 0, то ошибка (выход)
          INC     H            ;проверка y-координаты
          DEC     H            ; на нулевое значение
          RET     Z            ;если равна 0, то ошибка (выход)
          LD      L,6(IX)
          LD      H,7(IX)      ;новые x-,y-координаты ("куда")
          LD      A,#0xBF      ;максимально возможная y-координата
          CP      H            ;проверяем новую y-координату
          RET     C            ;если не в экране - выход
          LD      L,0(IX)
          LD      H,1(IX)      ;x1-,y1-координаты ("откуда")
          CP      H            ;проверяем y1 на вхождение в экран
          RET     C            ;если за экраном, то выходим
          LD      E,2(IX)
          LD      D,3(IX)      ;x2-,y2-координаты ("откуда")
          CP      D            ;y2 находится в экране?
          RET     C            ;если нет, то выход из процедуры
          LD      A,E          ;координата x2
          CP      L            ;сравнили с координатой x1
          JR      NC,GO_PSC1$  ;если L больше E, то всё нормально
          EX      DE,HL        ;иначе - поменяли их местами
GO_PSC1$: LD      A,D          ;координата y2
          CP      H            ;сравнили с координатой y1
          JR      NC,GO_PSC2$  ;если H больше D, то перепрыгиваем
          LD      D,H          ;иначе - меняем
          LD      H,A          ; их местами
GO_PSC2$: LD      A,D          ;большая из y-координат
          SUB     H            ;вычитаем меньшую y-координату
          INC     A            ;и прибавляем 1
          EXX                  ;перешли к альтернативным регистрам
          LD      B,A          ;величина смещения по y (высота)
          EXX                  ;вернулись к основным регистрам
          LD      A,E          ;большая из x-координат
          SUB     L            ;вычитаем меньшую x-координату
          INC     A            ;прибавили единичку
          EXX                  ;сменили набор регистров
          LD      C,A          ;величина смещения по x (ширина)
          EXX                  ;вернулись к осн. набору регистров
          PUSH    AF           ;закинули один байт на стек (любой)
          INC     SP           ; - это необходимо для завершения
          LD      C,#0x08      ;число бит в одном байте
LP_PSC1$: LD      A,E          ;запоминаем в альтернативном акку-
          EX      AF,AF        ; муляторе коорд. x окончания линии
LP_PSC2$: PUSH    HL           ;запоминаем регистры HL,BC на стеке
          PUSH    BC           ; чтобы не испортились
          CALL    __POINT__    ;вызов процедуры проверки точки
          POP     BC           ;восстанавливаем сохраненные
          POP     HL           ; регистры BC,HL со стека
          ADD     A,#0xFF      ;если A>0, то флаг CF включится
          RR      B            ;"вкручиваем" этот бит в регистр B
          DEC     C            ;уменьшаем счетчик количества битов
          JR      NZ,GO_PSC3$  ;если не ноль, то перепрыгиваем
          PUSH    BC           ;иначе - забрасываем на стек
          INC     SP           ; регистр B (только 1 байт)
          LD      C,#0x08      ; и устанавливаем счетчик битов
GO_PSC3$: LD      A,E          ;текущая x-координата
          DEC     E            ;движемся по линии влево
          CP      L            ;проверка на окончание линии
          JR      NZ,LP_PSC2$  ;крутим цикл по линии
          EX      AF,AF        ;восстанавливаем значение
          LD      E,A          ; x-координаты из альтернативного A
          LD      A,D          ;текущая y-координата
          DEC     D            ;движемся по строчкам вверх
          CP      H            ;это была последняя линия?
          JR      NZ,LP_PSC1$  ;если нет, то крутим цикл по линиям
          LD      A,#0x08      ;число битов в байте
          SUB     C            ;A=число заполненных битов в рег. B
          JR      NZ,GO_PSC4$  ;если не ноль, то перепрыгиваем
          LD      A,C          ;A=C=8 - число бит в байте
          DEC     SP           ;снимаем со стека последний
          POP     BC           ; заброшенный туда байт
GO_PSC4$: LD      C,A          ;сколько битов данных в посл. байте
          LD      E,6(IX)
          LD      D,7(IX)      ;новые x-,y-координаты ("куда")
LP_PSC3$: LD      A,E          ;сохраняем x-координату начала
          EX      AF,AF        ; линии изображения в A''
          EXX                  ;переход к альтернативным регистрам
          LD      E,C          ;это будет счетчик точек по x
LP_PSC4$: EXX                  ;вернулись к осн. набору регистров
          EX      AF,AF        ;переход к альтерн. флаг. регистру
          RLC     B            ;флаг CF - выводить/не_выв. точку
          EX      AF,AF        ;вернулись к нормальным флагам
          PUSH    BC           ;сохраняем байт данных и сч. битов
          LD      L,4(IX)
          LD      H,5(IX)      ;масштабность увеличения по x и y
          LD      B,H          ;сохранили масштабы увеличения
          LD      C,L          ; в регистрах C и B (x и y)
          PUSH    DE           ;сохраняем коор-ты (цикл по линиям)
LP_PSC5$: PUSH    DE           ;сохраняем коор-ты (цикл по точкам)
LP_PSC6$: PUSH    HL           ;сохраняем регистры HL и BC
          PUSH    BC           ; перед вызовом процедуры POINT
          CALL    __POINT__    ;расчет адреса в экране и маски
          LD      A,C          ;маска точки (бит включен)
          POP     BC           ;восстановили BC со стека
          EX      AF,AF        ;проверяем альтернативный флаг CF
          JR      C,GO_PSC5$   ;если он включен, то перепрыгиваем
          EX      AF,AF        ;сохраняем этот флаг CF
          CPL                  ;инвертируем маску бита точки
          AND     (HL)         ; и с её помощью сбрасываем пиксел
          JR      GO_PSC6$     ;переход на продолжение
GO_PSC5$: EX      AF,AF        ;флаг CF делаем снова альтерн-ным
          OR      (HL)         ;включаем пиксел
GO_PSC6$: LD      (HL),A       ;запись измененного байта в экран
          POP     HL           ;восстанавливаем HL (сч. масштаба)
          INC     E            ;переход к сл. точке в линии экрана
          DEC     L            ;уменьшаем счетчик масштаба по x
          JR      NZ,LP_PSC6$  ;пока не ноль, продолжаем цикл
          LD      L,C          ;восстанавливаем значение x-масшт.
          POP     DE           ;восстан-ем координаты начала линии
          INC     D            ;переход к следующей линии в экране
          DEC     H            ;уменьшаем счетчик масштаба по y
          JR      NZ,LP_PSC5$  ;и крутимся, пока он не достигнет 0
          LD      H,B          ;восстанавливаем значение y-масшт.
          POP     DE           ;восстан-ем координаты начала точки
          LD      A,E          ;переход к началу следующего
          ADD     A,L          ; прямоугольника, изображающего
          LD      E,A          ; одну точку изображения (вправо)
          POP     BC           ;восстанавливаем байт д-х и счетчик
          DEC     C            ;уменьшаем счетчик битов в байте B
          JR      NZ,GO_PSC7$  ;если есть ещё биты, то переход
          DEC     SP           ;иначе - считываем со стека
          POP     BC           ; следующий байт данных в регистр B
          LD      C,#0x08      ;устанавливаем счетчик битов
GO_PSC7$: EXX                  ;переход к альтернативным регистрам
          DEC     E            ;уменьшаем счетчик точек в строчке
          JR      NZ,LP_PSC4$  ;если ещё есть точки, то крутимся
          EXX                  ;вернулись к осн. набору регистров
          EX      AF,AF        ;восстанавливаем из альтернативного
          LD      E,A          ; аккумулятора x-координату строчки
          LD      A,D          ;переход к началу следующего прямо-
          ADD     A,H          ; угольника, изображающего одну
          LD      D,A          ; точку изображения (вниз)
          EXX                  ;переход к альтернативным регистрам
          DEC     B            ;уменьшаем счетчик строк спрайта
          EXX                  ;вернулись к осн. набору регистров
          JR      NZ,LP_PSC3$  ;цикл, если строчки не закончились
__endasm;
} //Best40_PSCALER

/*--------------------------------- Cut here ---------------------------------*/
/*

   http://zxpress.ru/book_articles.php?id=671

   Спрайты, смещение которых относительно байта равно 0 печатаются вообще
отдельной подпрограммкой и появляются на экране практически мгновенно. Объём
расходуемой памяти немного увеличился, но на притягательность любой графической
программы влияет прежде всего скорость вывода на экран, так что это не так уж и
страшно. Вдобавок, процедуру можно вызывать как из бейсика, так и из машинных
кодов, что более актуально. Длина процедуры 220 байт.

Listing 2. Быстрый вывод спрайта

;      SPRITE OUTPUT 2.3
;      (C)SERZHSOFT'1996

*/

void Best40_PUTSPR (
  unsigned char x, unsigned char y, unsigned char len, unsigned char hgt,
  unsigned int adr, unsigned char mode) __naked __z88dk_callee {
__asm
         POP     HL
         EXX
         POP     DE       ;XY-координаты спрайта
         POP     BC       ;ширина спрайта в байтах и высота в пикселях
         LD      A, C
         LD      C, B     ;меняем местами, чтобы внутр. цикл был DJNZ
         LD      B, A
         POP     HL       ;адрес спрайта
         DEC     SP
         EXX
         EX      (SP),HL  ;режим вывода на экран
         LD      A, H
         EXX
         PUSH    IX
PUTSPR$: ;точка входа из маш. кодов
         ;E: X-координата, D: Y-координата
         ;B: ширина, C: высота
         ;HL: адрес спрайта
         ;A: режим вывода (0=OR, 1=XOR, 2=AND)
         EX      AF,AF    ;альтернативный аккумулятор
         XOR     A        ; обнуляется -
         EX      AF,AF    ; это будет маска для сдвига
         CP      #1       ;проверка:
         LD      A,#180   ; если A<1 (т.е. A=0), то
         JR      C,GOPS1$ ; A=180 (OR H) и переход
         LD      A,#172   ;если A=1, то
         JR      Z,GOPS1$ ; A=172 (XOR H) и переход
         LD      A,#164   ;если A>1, то A=164 (AND H)
         EX      AF,AF    ;раз AND, значит необходимо
         CPL              ; AF''=255, что и
         EX      AF,AF    ; выполняем (A=0, CPL => A=255)
GOPS1$:  LD      (#MODE_1$),A    ;исправляем
         INC     A               ; необходимые
         LD      (#MODE_2$),A    ; команды вывода
         INC     A               ; в зависимости
         LD      (#MODE_5$),A    ; от режима (OR, XOR, AND)
         EX      AF,AF           ;A=маска сдвига
         LD      (#MODE_0$+1),A  ;поместили "куда надо"
         AND     E               ;операция "и" с X-коорд.
         AND     #0x7            ;теперь A=0..7: смещение
         LD      (#MODE_4$+2),A  ; в таблице TBL_OR
         LD      A,E      ;координата X
         AND     #0x7     ;позиция первого бита в байте экрана
         EX      AF,AF    ;запомнили в AF''
         PUSH    HL       ;пихнули адрес спрайта на стек
         LD      A,#0xBF  ;максимальная Y-координата
         SUB     D        ;отсчет координат снизу-вверх
         LD      D,A      ;------------------------
         RRA              ; расчет адреса в экране
         SCF              ;    по координатам:
         RRA              ;
         RRA              ;на входе:
         AND     #0x5F    ; E=X-координата
         LD      H,A      ; D=Y-координата
         XOR     E        ;
         AND     #0x7     ;на выходе:
         XOR     E        ; HL=адрес в экране
         RRCA             ;
         RRCA             ;D,E  не меняются
         RRCA             ;
         LD      L,A      ;используется
         LD      A,D      ; аккумулятор
         XOR     H        ;
         AND     #0x7     ;
         XOR     H        ;
         LD      H,A      ;------------------------
         EX      AF,AF           ;вспомнили позицию бита
         JR      Z,NOSHFT$       ;если =0, то переход
         LD      (#JUMPER$+1),A  ;поместили в JR для прыжка
         LD      IX,#TBL_OR$     ;IX=адрес таблицы TBL_OR
MODE_4$: LD      A,0(IX)         ;байт со смещением 0..7 из
         LD      (#MODE_3$+1),A  ; таблицы (для OR)
         POP     IX       ;IX=адрес начала спрайта
         EX      DE,HL    ;DE=адрес байта в экране
LPPS1$:  PUSH    BC       ;сохранили ширину и высоту
         LD      A,E      ;сохранили регистр E
         EX      AF,AF    ; в AF''
LPPS2$:  LD      L,0(IX)  ;L=байт спрайта
MODE_0$: LD      H,#0x0   ;H=0 для OR, XOR; H=255 для AND
JUMPER$: JR      .+2      ;прыжок через лишние ADD HL,HLы
         ADD     HL,HL    ;-------------
         ADD     HL,HL    ;
         ADD     HL,HL    ;сдвиг байта
         ADD     HL,HL    ; спрайта
         ADD     HL,HL    ; нужное
         ADD     HL,HL    ; число раз
         ADD     HL,HL    ;
         ADD     HL,HL    ;-------------
         LD      A,(DE)   ;взяли байт с экрана
MODE_1$: OR      H        ;OR, XOR или AND
         LD      (DE),A   ;поставили назад
         INC     E        ;следующий байт экрана
         LD      A,L      ;дополнили регистр L нужными
MODE_3$: OR      #0x0     ; включенными битами (как-будто
         LD      L,A      ; не ADD HL,HL'ы, A RLC HL'ы)
         LD      A,(DE)   ;байт с экрана
MODE_2$: OR      L        ;OR,XOR или AND
         LD      (DE),A   ;поместили обратно
         INC     IX       ;следующий байт спрайта
         DJNZ    LPPS2$   ;повторять "ширина" раз
         EX      AF,AF    ;восстановили
         LD      E,A      ; регистр E
         INC     D        ;следующая линия экрана
         LD      A,D      ;если мл. 3 бита регистра D
         AND     #0x7     ; равны нулю, то
         JR      Z,GOPS3$ ; переход на корректировку
GOPS2$:  POP     BC       ;восстановили ширину и высоту
         DEC     C        ;повторять цикл
         JR      NZ,LPPS1$; "высота" раз
         POP     IX
         RET              ;выход из процедуры
GOPS3$:  LD      A,E      ;--------------------
         ADD     A,#0x20  ;
         LD      E,A      ;корректировка DE
         JR      C,GOPS2$ ; для перехода на
         LD      A,D      ; линию ниже
         SUB     #0x8     ; (в экране)
         LD      D,A      ;
         JR      GOPS2$   ;--------------------
;
NOSHFT$: ;вывод спрайта по байтам (X-координата кратна 8)
         POP     DE       ;DE=адрес спрайта в памяти
LPPS3$:  PUSH    BC       ;сохранили ширину и высоту
         LD      A,L      ;запомнили
         EX      AF,AF    ; регистр L в AF''
LPPS4$:  LD      A,(DE)   ;взяли байт спрайта
MODE_5$: OR      (HL)     ;OR, XOR или AND
         LD      (HL),A   ;поместили на экран
         INC     DE       ;следующий байт спрайта
         INC     L        ;следующий байт экрана
         DJNZ    LPPS4$   ;цикл "ширина" раз
         EX      AF,AF    ;восстановили
         LD      L,A      ; регистр L
         INC     H        ;перешли к следующей линии экрана
         LD      A,H      ;если младшие 3 бита регистра H
         AND     #0x7     ; равны нулю, то
         JR      Z,GOPS5$ ; перейти на корректировку
GOPS4$:  POP     BC       ;вспомнили ширину и высоту
         DEC     C        ;повторили
         JR      NZ,LPPS3$; "высота" раз
         POP     IX
         RET              ;выход из процедуры
GOPS5$:  LD      A,L      ;-------------------
         ADD     A,#0x20  ;
         LD      L,A      ;корректировка HL
         JR      C,GOPS4$ ; для перехода
         LD      A,H      ; на линию ниже
         SUB     #0x8     ; (в экране)
         LD      H,A      ;
         JR      GOPS4$   ;-------------------
;
;таблица для наложения на байты после их сдвига
;(для имитации команд "RLC HL" через ADD HL,HL)
TBL_OR$: .DB     #0x00,#0x7F,#0x3F,#0x1F,#0x0F,#0x07,#0x03,#0x01
;
;END OF SPRITE OUTPUT 2.3
__endasm;
} //Best40_PUTSPR

/*--------------------------------- Cut here ---------------------------------*/
void Best40_SCREEN_APART (unsigned char steps) __naked __z88dk_fastcall {
__asm
;  SCREEN-APART
;(c) SerzhSoft, 11 july 1997
          LD      B,L         ;B=число пар сдвигов экрана в стороны
APART$:                       ;Используется переменная ATTR_P
LP_APR1$: PUSH    BC          ;сохраняем счетчик сдвигов на стеке
          LD      A,(23693)   ;A=атрибуты для заполн. после сдига
          LD      DE,#0x5AFF  ;самый последний байт атрибутов
LP_APR2$: LD      H,D         ;скопировали этот адрес
          LD      L,E         ; в HL и уменьшили на 1:
          DEC     HL          ; адрес предпоследнего байта линии
          LD      BC,#0x000F  ;сдвигать: 15 байт
          LDDR                ;сдвиг правой полу-линии вправо
          LD      (DE),A      ;устанавливаем новое значение
          LD      BC,#0xFFF2  ;коррекция р-ра HL - теперь он
          ADD     HL,BC       ; указывает на второй байт линии
          LD      E,L         ;DE=HL
          DEC     E           ;первый байт слева в линии
          LD      BC,#0x000F  ;будем сдвигать 15 байт
          LDIR                ;сдвиг левой полу-линии влево
          LD      (DE),A      ;устанавливаем новый байт (очистка)
          LD      BC,#0xFFEF  ;коррекция регистра DE -
          ADD     HL,BC       ; переход на одну
          EX      DE,HL       ; линию вверх в экране (атрибутах)
          BIT     3,D         ;если атрибуты не кончились,
          JR      NZ,LP_APR2$ ; то крутим цикл
          XOR     A           ;перешли в область графики
          BIT     6,D         ;если мы пока еще не залезли в ПЗУ,
          JR      NZ,LP_APR2$ ; то продолжаем крутить цикл
          POP     BC          ;восстанавливаем счетчик сдвигов
          DJNZ    LP_APR1$    ;крутим цикл положенное число раз
          RET
__endasm;
} //Best40_SCREEN_APART

/*--------------------------------- Cut here ---------------------------------*/
void Best40_PRSTR_AT_E (unsigned char x, unsigned char y, unsigned char *str) __naked __z88dk_callee {
__asm
; ПЕЧАТЬ ТЕКСТА С ТОЧНОСТЬЮ ДО ПИКСЕЛА ПО Y
;(c) Steve Turner, Body #06
; http://zxpress.ru/article.php?id=3206

          POP     HL
          POP     DE
          EX      (SP),HL
          LD      (INPUT$+1),HL
          LD      A,D
          AND     #0x38       ;Определяем ряд
          ADD     A
          ADD     A
          ADD     E           ;Прибавили х
          LD      E,A         ;Младший байт
          LD      A,D
          RRA
          RRA
          RRA
          AND     #0x18       ;Определяем треть экрана
          LD      B,A
          LD      A,D
          AND     #0x7        ;Строка в ряду
          ADD     B
          ADD     #0x40       ;Старший байт
          LD      D,A
INPUT$:   LD      HL,#0       ;Адрес текста
          LD      A,(HL)
          OR      A
          RET     Z           ;Конец текста
          LD      (OUTPUT$+1),DE
          INC     HL
          LD      (INPUT$+1),HL
          CP      #0xFF
          JR      NZ,CHAR$    ;Переход к новой строке под первой позицией печати
OUTLIN$:  LD      DE,#0       ;Начальная строка
          LD      A,E
          ADD     #0x20
          LD      E,A
          RET     NC
          LD      A,D         ;Другая треть экрана
          ADD     #8
          CP      #0x58
          RET     NC
          LD      D,A
          LD      (OUTLIN$+1),DE
          JR      INPUT$
CHAR$:    LD      L,A          ;Поиск символа
          LD      H,#0
          ADD     HL,HL
          ADD     HL,HL
          ADD     HL,HL
          LD      DE,(23606)   ;Адрес шрифта в ПЗУ минус 256 байт
          ADD     HL,DE
OUTPUT$:  LD      DE,#0        ;Адрес печати
          LD      A,D
          CP      #0x58
          RET     NC
          LD      B,#8
EIGHT$:   LD      A,(HL)       ;Выдаёт 8 строк символа
          LD      (DE),A
          INC     HL
          LD      A,D
          AND     #7
          INC     A
          CP      #8
          JR      NZ,NONEW$
          LD      A,D
          AND     #0xF8
          LD      D,A
          LD      A,E
          ADD     #0x20
          LD      E,A
          JR      NC,NEXTSL$
          LD      A,D
          ADD     #8
          LD      D,A
NONEW$:   INC     D
NEXTSL$:  DJNZ    EIGHT$
          LD      DE,(OUTPUT$+1)
NEXTLT$:  INC     E
          JR      NZ,INPUT$
          LD      A,D
          ADD     #8
          LD      D,A
          JR      INPUT$
__endasm;
} //Best40_PRSTR_AT_E

/*--------------------------------- Cut here ---------------------------------*/
void Best40_FILLED_CIRCLE (unsigned char x, unsigned char y, unsigned char radius) __naked __z88dk_callee {
__asm
; https://github.com/impomatic/z80snippets/blob/master/filledcircle.asm

; FAST FILLED CIRCLE - Sinclair Spectrum, displays filled circle
; on entry, d = x-centre, e = y-centre, c = radius
; on exit, a, bc, de, hl corrupt
; Length 106 - John Metcalf, Sun 28 Feb 1999

; Draws filled circles very quickly. An assortment of tricks have
; been used to achieve this. This new version is over 10% faster
; than the previous after further optimizing the inner loops.

          POP   HL
          POP   BC
          LD    E,B
          LD    D,C       ; E = X-centre, D = Y-centre
          DEC   SP
          POP   BC
          LD    C,B       ; C = radius
          PUSH  HL

          LD    B,#0
          LD    A,E       ; Subtract radius from y-centre
          INC   C
          SUB   C
          LD    E,A

          LD    H,B       ; HL = 0
          LD    L,B

NEXT$:    PUSH  BC
          PUSH  HL

          LD    BC,#65280 ; Triangular root :-)
CALC$:    DEC   C
          ADD   HL,BC
          JR    C,CALC$

          LD    A,E       ; Calc pos in screen memory
          CP    #192
          JR    NC,OFFSCR$
          RRCA
          SCF
          RRA
          RRCA
          LD    L,A
          XOR   E
          AND   #88
          XOR   E
          AND   #95
          LD    H,A

          LD    A,D
          ADD   A,C
          RL    C
          LD    B,A
          XOR   L
          AND   #7
          XOR   B
          RRCA
          RRCA
          RRCA
          LD    L,A

          XOR   A         ; Calc first part byte (if any)
          SUB   B
          AND   #7
          JR    Z,NOHALF$
          LD    B,A
          XOR   A
          DEC   C
VAIN$:    INC   C
          JR    Z,ROTB$
          SCF
          RLA
          DJNZ  VAIN$
          INC   C
          OR    (HL)
          LD    (HL),A
          INC   HL
NOHALF$:  XOR   A         ; Calc full bytes (if any)
          SUB   C
          RRCA
          RRCA
          RRCA
          AND   #31
          JR    Z,NOFULL$
          LD    B,A
          LD    A,#255
DRAW$:    LD    (HL),A
          INC   HL
          DJNZ  DRAW$
NOFULL$:  LD    A,C       ; Calc final part byte (if any)
          AND   #7
          JR    Z,OFFSCR$
          LD    B,A
          LD    A,#255
ROTB$:    ADD   A,A
          DJNZ  ROTB$
DISPLAY$: OR    (HL)
          LD    (HL),A

OFFSCR$:  POP   HL
          POP   BC
          INC   E         ; Next line
          DEC   C
          JR    NZ,SKIP$
          DEC   BC
SKIP$:    ADC   HL,BC
          JR    NZ,NEXT$
          RET
__endasm;
} //Best40_FILLED_CIRCLE


/* https://github.com/impomatic/z80snippets/
   http://zxpress.ru/book_articles.php?id=671

*********************************************
(c) Колотов Сергей, г.Шадринск

   В ZX РЕБЮ 96/4-5, читая раздел "Этюды", я наткнулся на процедуры опроса
клавиш. Принцип, использованный  А. Шокало  совсем неплох, но сами программы
вызвали у меня внутренний протест. "Слишком много лишних байтов!" - подумал я и
сел за компьютер.
   Вскоре новые процедурки уже были  написаны и отлажены. Принцип работы остался
прежним, а вот размер  значительно  уменьшился. Итак, "свежие" процедуры:
Listing 1. Клавиатурные процедурки.

REDEF   ;ждет нажатия на любую клавишу
        ;на выходе:
        ; B=старший байт порта клавиатуры
        ; A=маска нажатой клавиши (бит установлен в 1)
        LD      BC,#FEFE ;адрес порта опроса клавиатуры
LP_DEF  RRC     B        ;"пробегаем" все полуряды
        IN      A,(C)    ;считываем данные из порта
        CPL              ;инвертируем все биты
        AND     #1F      ;отбрасываем 3 ненужных бита
        JR      Z,LP_DEF ;если нет нажатий, то продолжить
        RET              ;возврат из процедуры
;
TRANSF  ;декодирует данные REDEF в код символа
        ;на входе:
        ; B=старший байт порта клавиатуры
        ; A=маска нажатой клавиши (бит установлен в 1)
        ;на выходе:
        ; A=код клавиши (C.S.=#E3, S.S.=#0E, ENTER=#0D)
        LD      H,B     ;H=порт клавиатуры
        LD      B,#04   ;определяем
LPTR1   RRA             ; порядковый
        JR      C,GOTR1 ; номер
        DJNZ    LPTR1   ; клавиши
GOTR1   LD      A,B     ; в полуряде
        ADD     A,A     ;умножаем
        ADD     A,A     ; его
        ADD     A,A     ; на 8
        LD      B,#07   ;определяем
LPTR2   RR      H       ; порядковый
        JR      NC,GOTR2; номер
        DJNZ    LPTR2   ; полуряда
GOTR2   ADD     A,B     ;прибавляем K аккумулятору
        ADD     A,#05   ;смещение
        LD      L,A     ; в таблице
        LD      H,#02   ;адрес таблицы в пзу: #0205
        LD      A,(HL)  ;A=код клавиши из таблицы
        RET             ;выход из процедуры

   Метка REDEF. Ожидается  нажатие  любой клавиши (кроме RESET, естественно), и
результат работы помещается в регистры  A  и B (как не вспомнить: "сидели на
трубе!"). Регистр B  содержит  старший  байт  адреса порта клавиатуры (полуряд),
а в аккумуляторе находится маска нажатой клавиши (соответствующий бит включен).
Длина процедуры 13 байт.
   Метка TRANSF - перекодировка в код символа. Результаты предыдущей процедуры
перерабатываются и, в соответствии с таблицей
из ПЗУ (адрес таблицы #0205),  код  символа помещается в аккумулятор. То есть
A=(#30..#39, #41..#5A) - цифры и прописные английские буквы. Следует также
отметить, что несимвольным клавишам присвоены  следующие коды: SPACE - #20,
CAPS SHIFT - #E3,  SYMBOL SHIFT - #0E, ENTER - #0D. Длина процедуры 28 байт.

*/

/*

CODING - Вращение спрайтов.
http://zxpress.ru/article.php?id=7876

Печать чисел в различных системах счисления.
http://zxpress.ru/article.php?id=1692
http://zxpress.ru/article.php?id=7872

Обмен опытом - Процедура генерации синуса.
http://zxpress.ru/article.php?id=5525

Программа "теневой контур" (SHADOW-PROCESSOR)
http://zxpress.ru/article.php?id=1766

ОРГАНИЗАЦИЯ УПРАВЛЕНИЯ И ИНТЕРФЕЙС "СТРЕЛКА".
http://zxpress.ru/book_articles.php?id=668

*/
