(* Copyright (C) 2012-2013 Oleg N. Cher, VEDAsoft Oberon Club *)
(* http://zx.oberon2.ru *)

MODULE XDevCmd;
IMPORT
	Controllers, Converters, Dialog, Files, HostFiles, i21sysCalls, Kernel,
	XDevMisc, Ofront := OfrontCmd, OfrontBrowser, OfrontOPM, StdLog,
	Stores, Strings, TextMappers, TextModels, TextViews, Views, Windows;

CONST
	BinDir = "Bin";
	ObjDir = "Obj";
	NotFound = -1;

VAR
	rootDir: HostFiles.FullName;

TYPE
	tOdc* = POINTER TO RECORD
		f: TextMappers.Formatter;
		t*: TextModels.Model; v: TextViews.View;
		loc: Files.Locator;
		res: INTEGER;
		conv: Converters.Converter;
		fileName: Files.Name;
	END;

PROCEDURE (odc: tOdc) OpenAt* (IN folderName: ARRAY OF CHAR), NEW;
BEGIN
	odc.loc := Files.dir.This(folderName);
	odc.t := TextModels.dir.New(); (* ???????? ??????? ???????? ?????? *)
	odc.f.ConnectTo(odc.t);
END OpenAt;

PROCEDURE (odc: tOdc) Save* (IN fileName: ARRAY OF CHAR), NEW;
VAR
	res: INTEGER;
BEGIN 
	odc.v := TextViews.dir.New(odc.t); (* ???????? ??????????? ?????? ??? ?????????? ???? ?????? *)
	odc.fileName := fileName$;
	odc.conv := NIL;
	Views.Register(odc.v, FALSE, odc.loc, odc.fileName, odc.conv, odc.res);
END Save;

PROCEDURE (odc: tOdc) String* (IN str: ARRAY OF CHAR), NEW;
VAR
	n: INTEGER;
BEGIN
	n := 0;
	WHILE str[n] # 0X DO
		IF str[n] = 9X THEN odc.f.WriteTab ELSE odc.f.WriteChar(str[n]) END;
		INC(n);
	END;
END String;

PROCEDURE (odc: tOdc) Ln*, NEW;
BEGIN
	odc.f.WriteLn;
END Ln;

PROCEDURE (odc: tOdc) Tab*, NEW;
BEGIN
	odc.f.WriteTab;
END Tab;

PROCEDURE (odc: tOdc) Bool* (bool: BOOLEAN), NEW;
BEGIN
	IF bool THEN odc.String("TRUE") ELSE odc.String("FALSE") END;
END Bool;

PROCEDURE (odc: tOdc) Int* (int: INTEGER), NEW;
VAR
	str: ARRAY 16 OF CHAR;
BEGIN
	Strings.IntToString(int, str); odc.String(str);
END Int;

PROCEDURE (odc: tOdc) Real* (real: REAL), NEW;
VAR
	str: ARRAY 32 OF CHAR;
BEGIN
	Strings.RealToString(real, str); odc.String(str);
END Real;

PROCEDURE MapStringOdc* (
	IN dir, name: Files.Name; IN opt: ARRAY OF CHAR; OUT val: ARRAY OF CHAR);
VAR
	s: Dialog.String;
	loc: Files.Locator;
	v: Views.View; t: TextModels.Model;
	r: TextModels.Reader;
	n: INTEGER;
	ch: CHAR;
	found: BOOLEAN;
BEGIN
	found := FALSE; val := 0X;
	v := Views.OldView(Files.dir.This(dir), name$);
	IF (v # NIL) & (v IS TextViews.View) THEN
		t := v.ThisModel()(TextModels.Model);
		r := t.NewReader(NIL);
		s := 0X; n := 0;
		WHILE ~ r.eot DO
			r.ReadChar(ch);
			IF (ch = "=") OR (ch = 9X) THEN
				s[n] := 0X;
				IF s$ = opt THEN found := TRUE END;
				s := 0X; n := 0;
			ELSIF (ch = TextModels.line) OR (ch = TextModels.para) THEN
				s[n] := 0X;
				IF found THEN val := s$; RETURN END;
				s := 0X; n := 0;
			ELSE
				s[n]:= ch; INC(n);
			END;
		END;
	END;
END MapStringOdc;

PROCEDURE MapStringTxt* (
	IN dir, name: Files.Name; IN opt: ARRAY OF CHAR; OUT val: ARRAY OF CHAR);
VAR
	s: Dialog.String;
	file: Files.File; rd: Stores.Reader;
	n: INTEGER;
	ch: SHORTCHAR;
	found: BOOLEAN;
BEGIN
	found := FALSE; val := 0X;
	file := Files.dir.Old(Files.dir.This(dir), name$, TRUE);
	IF file # NIL THEN
		rd.ConnectTo(NIL); rd.ConnectTo(file);
		s := 0X; n := 0;
		WHILE ~rd.rider.eof DO
			rd.ReadSChar(ch);
			IF (ch = "=") OR (ch = 9X) THEN
				s[n] := 0X;
				IF s$ = opt THEN found := TRUE END;
				s := 0X; n := 0;
			ELSIF (ch = 0DX) OR (ch = 0AX) THEN
				s[n] := 0X;
				IF found THEN val := s$; file.Close; RETURN END;
				s := 0X; n := 0;
			ELSE
				s[n]:= ch; INC(n);
			END;
		END;
		file.Close;
	END;
END MapStringTxt;

PROCEDURE Open*;
BEGIN
	Dialog.ShowStatus("#XDev:Building");
	StdLog.buf.Delete(0, StdLog.buf.Length());
END Open;

PROCEDURE Close*;
BEGIN
	StdLog.text.Append(StdLog.buf);
	IF OfrontOPM.noerr THEN Dialog.ShowStatus("#XDev:Ok") END;
	Kernel.Cleanup;
END Close;

PROCEDURE ExportText (
  md: TextModels.Model; loc: Files.Locator; IN name: Files.Name): BOOLEAN;
VAR
	ch: CHAR; res: INTEGER; rd: TextModels.Reader;
	file: Files.File; wr: Files.Writer;
BEGIN
	file := Files.dir.New(loc, Files.dontAsk);
	IF file = NIL THEN RETURN FALSE END;
	wr := file.NewWriter(NIL); wr.SetPos(0);
	rd := md.NewReader(NIL);
	rd.ReadChar(ch);
	WHILE ~rd.eot DO
		IF ch = 0DX THEN wr.WriteByte(0DH); wr.WriteByte(0AH);
		ELSIF ch # 2X THEN
			wr.WriteByte(SHORT(SHORT(ORD(ch))));
		END;
		rd.ReadChar(ch);
	END;
	file.Register(name, "", Files.dontAsk, res);
	file.Close;
	RETURN TRUE
END ExportText;

PROCEDURE GetNameWoExt (name: ARRAY OF CHAR; OUT woext: ARRAY OF CHAR);
CONST
	ExtDelimiter = ".";
VAR
	pos, lastpos: INTEGER;
BEGIN
	pos := LEN(name$);
	Strings.Find(name, ExtDelimiter, 0, lastpos);
	WHILE lastpos # NotFound DO
		pos := lastpos;
		Strings.Find(name, ExtDelimiter, lastpos + 1, lastpos);
	END;
	woext := name$; woext[pos] := 0X;
END GetNameWoExt;

PROCEDURE GetSubsysDirByLocator* (loc: Files.Locator; OUT subdir: ARRAY OF CHAR);
VAR
	s1, s2: HostFiles.FullName; dis, i, j, pos: INTEGER; ch: CHAR;
BEGIN
	subdir := "";
	WITH loc: HostFiles.Locator DO
		Strings.Find(loc.path, rootDir, 0, pos);
		IF pos = 0 THEN (* rootDir found in loc.path. *)
			dis := LEN(rootDir$) + 1(*"/"*);
		ELSE
			dis := 0;
		END;
		i := 0; ch := loc.path[dis]; pos := 0; j := 0;
		WHILE ch # 0X DO
			IF (ch = "\") OR (ch = "/") THEN
				ch := "/"; pos := i + 1; j := 0
			ELSE
				s2[j] := ch; INC(j);
			END;
			s1[i] := ch; INC(i); ch := loc.path[i + dis];
		END;
		s1[pos] := 0X; s2[j] := 0X;
		IF (s2[0] = 0X) OR ((CAP(s2[0]) = "M") & (CAP(s2[1]) = "O")
			& (CAP(s2[2]) = "D") & (s2[3] = 0X)) THEN
				subdir := s1$;
		ELSE
				subdir := s1$ + s2$ + "/";
		END;
	END;
END GetSubsysDirByLocator;

PROCEDURE Exists* (loc: Files.Locator; IN fileName: ARRAY OF CHAR): BOOLEAN;
VAR
	file: Files.File; found: BOOLEAN;
BEGIN
	file := Files.dir.Old(loc, fileName$, TRUE);
	found := file # NIL;
	IF found THEN file.Close END;
RETURN found
END Exists;

PROCEDURE ExistsDir (IN subSys, dirName: ARRAY OF CHAR): BOOLEAN;
VAR
	dir: Files.File; found: BOOLEAN;
BEGIN
	RETURN XDevMisc.DirectoryExists(subSys + "\" + dirName)
END ExistsDir;

PROCEDURE HaveAtrMAIN (t: TextModels.Model): BOOLEAN;
VAR
	ch: CHAR; reader: TextModels.Reader;

	PROCEDURE Match (IN s: ARRAY OF CHAR): BOOLEAN;
	VAR
		i, n: INTEGER;
	BEGIN
		i := 0; n := LEN(s$);
		WHILE ~reader.eot & (ch = " ") DO reader.ReadChar(ch) END;
		WHILE ~reader.eot & (i < n) & (ch = s[i]) DO
			reader.ReadChar(ch); INC(i);
		END;
		RETURN i = n
	END Match;

BEGIN
	ASSERT(t # NIL, 20);
	reader := t.NewReader(reader); reader.SetPos(0);
	WHILE ~reader.eot DO
		reader.ReadChar(ch);
		IF Match("(*$MAIN*)") THEN RETURN TRUE END;
	END;
	RETURN FALSE
END HaveAtrMAIN;

PROCEDURE HaveAtrGPCP (t: TextModels.Model): BOOLEAN;
VAR
	ch: CHAR; reader: TextModels.Reader;

	PROCEDURE Match (IN s: ARRAY OF CHAR): BOOLEAN;
	VAR
		i, n: INTEGER;
	BEGIN
		i := 0; n := LEN(s$);
		WHILE ~reader.eot & (ch = " ") DO reader.ReadChar(ch) END;
		WHILE ~reader.eot & (i < n) & (ch = s[i]) DO
			reader.ReadChar(ch); INC(i);
		END;
		RETURN i = n
	END Match;

BEGIN
	ASSERT(t # NIL, 20);
	reader := t.NewReader(reader); reader.SetPos(0);
	WHILE ~reader.eot DO
		reader.ReadChar(ch);
		IF Match("(*$GPCP*)") THEN RETURN TRUE END;
	END;
	RETURN FALSE
END HaveAtrGPCP;

PROCEDURE HaveAtr866 (t: TextModels.Model): BOOLEAN;
VAR
	ch: CHAR; reader: TextModels.Reader;

	PROCEDURE Match (IN s: ARRAY OF CHAR): BOOLEAN;
	VAR
		i, n: INTEGER;
	BEGIN
		i := 0; n := LEN(s$);
		WHILE ~reader.eot & (ch = " ") DO reader.ReadChar(ch) END;
		WHILE ~reader.eot & (i < n) & (ch = s[i]) DO
			reader.ReadChar(ch); INC(i);
		END;
		RETURN i = n
	END Match;

BEGIN
	ASSERT(t # NIL, 20);
	reader := t.NewReader(reader); reader.SetPos(0);
	WHILE ~reader.eot DO
		reader.ReadChar(ch);
		IF Match("(*$866*)") THEN RETURN TRUE END;
	END;
	RETURN FALSE
END HaveAtr866;

PROCEDURE OfrontCompile* ; (** Call "Bin/compile.bat" script. *)
VAR
	t: TextModels.Model; w: Windows.Window;
	loc: Files.Locator; name, dir: Files.Name;
	spacePos: INTEGER; GPCP: BOOLEAN;
BEGIN
	Open;
	(* Try to find exact file name of current opened document: *)
	t := TextViews.FocusText();
	IF t # NIL THEN
		w := Windows.dir.Focus(Controllers.targetPath);
		IF (w # NIL) & (w.loc # NIL) & (w.name # "") THEN (* File name found. *)
			GetSubsysDirByLocator(w.loc, dir);
			GPCP := HaveAtrGPCP(t);
			IF ~GPCP THEN (* Launch the translation by Ofront: *)
				OfrontOPM.SetWorkDir(dir, dir, TRUE, ExistsDir(dir, "Sym"), "");
				OfrontOPM.options.mainprog := HaveAtrMAIN(t);
				Dialog.UpdateBool(OfrontOPM.options.mainprog);
				OfrontOPM.options.cp866 := HaveAtr866(t);
				Dialog.UpdateBool(OfrontOPM.options.cp866);
				IF ~Ofront.TranslateDone() THEN Close; RETURN END;
			ELSE (*GPCP*)
				IF ~ExportText(t, Files.dir.This(dir + ObjDir), w.name) THEN
					Dialog.ShowMsg("Couldn't save " + ObjDir + w.name$); Close; RETURN
				END;
			END;

			GetNameWoExt(w.name, name);
			Strings.Find(name, " ", 0, spacePos);
			IF spacePos # NotFound THEN
				StdLog.String("Module's file name must not contain a space.");
				StdLog.Ln;
				Close; RETURN
			END;

			(* Main compiling thread: *)
			loc := Files.dir.This(dir + BinDir);
			IF Exists(loc, "compile.bat") THEN (* Start "Bin/compile.bat Module". *)
				loc := Files.dir.This(dir + ObjDir); (* Start in /Obj directory. *)
				(* StdLog.String(loc(HostFiles.Locator).path$); StdLog.Ln; *)
				i21sysCalls.StartAt(loc, "..\Bin\compile.bat " + name$);
			ELSE
				StdLog.String('"' + dir + BinDir + '/' + 'compile.bat" not found.');
				StdLog.Ln;
			END;

		IF ~GPCP THEN
			(* Additional compiling thread: *)
			loc := Files.dir.This(dir + BinDir);
			IF Exists(loc, "compile64.bat") THEN (* Start "Bin/compile64.bat Mod". *)
				OfrontOPM.SetWorkDir(dir, dir, TRUE, ExistsDir(dir, "Sym64") ,"64");
				IF ~Ofront.TranslateDone() THEN Close; RETURN END;
				loc := Files.dir.This(dir + ObjDir + "64"); (* Start in /Obj64 *)
				i21sysCalls.StartAt(loc, "..\Bin\compile64.bat " + name$);
			END;
		END

		ELSE (* Module's file name not found. *)
			StdLog.String("First, specify a file name of the module, please.");
			StdLog.Ln;
		END;
	ELSE
		Dialog.ShowMsg("#XDev:NoTextViewFound")
	END;
	Close
END OfrontCompile;

PROCEDURE OfrontBuild* ; (** Call a BAT file that is appropriate to a source. *)
VAR
	t: TextModels.Model; w: Windows.Window; 
	loc: Files.Locator; name, dir: Files.Name;
	spacePos: INTEGER; GPCP: BOOLEAN;
BEGIN
	Open;
	(* Try to find exact file name of current opened document: *)
	t := TextViews.FocusText();
	IF t # NIL THEN
		w := Windows.dir.Focus(Controllers.targetPath);
		IF (w # NIL) & (w.loc # NIL) & (w.name # "") THEN (* File name found. *)
			GetSubsysDirByLocator(w.loc, dir);
			GPCP := HaveAtrGPCP(t);
			IF ~GPCP THEN (* Launch the translation by Ofront: *)
				OfrontOPM.SetWorkDir(dir, dir, TRUE, ExistsDir(dir, "Sym"), "");
				OfrontOPM.options.mainprog := HaveAtrMAIN(t);
				Dialog.UpdateBool(OfrontOPM.options.mainprog);
				OfrontOPM.options.cp866 := HaveAtr866(t);
				Dialog.UpdateBool(OfrontOPM.options.cp866);
				IF ~Ofront.TranslateDone() THEN Close; RETURN END;
			ELSE (*GPCP*)
				IF ~ExportText(t, Files.dir.This(dir + ObjDir), w.name) THEN
					Dialog.ShowMsg("Couldn't save " + ObjDir + w.name$); Close; RETURN
				END;
			END;

			(* Main building thread: *)
			loc := Files.dir.This(dir + ObjDir);
			GetNameWoExt(w.name, name); name := name$ + ".bat";
			IF Exists(loc, name) THEN
				i21sysCalls.StartAt(loc, name); (* Start "Obj/Module.bat" *)
			ELSE
				loc := Files.dir.This(dir + BinDir);
				IF Exists(loc, "build.bat") THEN (* Start "Bin/build.bat Module". *)
					GetNameWoExt(w.name, name);
					Strings.Find(name, " ", 0, spacePos);
					IF spacePos # NotFound THEN
						StdLog.String("Module's file name must not contain a space.");
						StdLog.Ln;
						Close; RETURN
					END;
					loc := Files.dir.This(dir + ObjDir); (* Start in /Obj directory. *)
					(* StdLog.String(loc(HostFiles.Locator).path$); StdLog.Ln; *)
					i21sysCalls.StartAt(loc, "..\Bin\build.bat " + name$);
				ELSE
					StdLog.String(
						'"' + dir + ObjDir + '/' + name + '"' + ' or ' +
						'"' + dir + BinDir + '/' + 'build.bat" not found.');
					StdLog.Ln;
				END;
			END;

		IF ~GPCP THEN (* Additional building thread: *)
			loc := Files.dir.This(dir + ObjDir + "64"); (* Start in /Obj64 *)
			GetNameWoExt(w.name, name); name := name$ + ".bat";
			IF Exists(loc, name) THEN
				OfrontOPM.SetWorkDir(dir, dir, TRUE, ExistsDir(dir, "Sym64"), "64");
				IF ~Ofront.TranslateDone() THEN Close; RETURN END;
				i21sysCalls.StartAt(loc, name); (* Start "Obj64/Module.bat" *)
			ELSE
				loc := Files.dir.This(dir + BinDir);
				IF Exists(loc, "build64.bat") THEN (* Start "Bin/build64.bat Module". *)
					GetNameWoExt(w.name, name);
					Strings.Find(name, " ", 0, spacePos);
					IF spacePos # NotFound THEN
						StdLog.String("Module's file name must not contain a space.");
						StdLog.Ln;
						Close; RETURN
					END;
					OfrontOPM.SetWorkDir(dir, dir, TRUE, ExistsDir(dir, "Sym64"), "64");
					IF ~Ofront.TranslateDone() THEN Close; RETURN END;
					loc := Files.dir.This(dir + ObjDir + "64"); (* Start in /Obj64 *)
					i21sysCalls.StartAt(loc, "..\Bin\build64.bat " + name$);
				END;
			END;
		END;

		ELSE (* Module's file name not found. *)
			StdLog.String("First, specify a file name of the module, please.");
			StdLog.Ln;
		END;
	ELSE
		Dialog.ShowMsg("#XDev:NoTextViewFound")
	END;
	Close
END OfrontBuild;

PROCEDURE ShowDef* ; (** Set work paths and call OfrontBrowser.ShowDef. *)
VAR
	t: TextModels.Model; w: Windows.Window; dir: Files.Name;
BEGIN
	(* Try to find exact file name of current opened document: *)
	t := TextViews.FocusText();
	IF t # NIL THEN
		w := Windows.dir.Focus(Controllers.targetPath);
		IF (w # NIL) & (w.loc # NIL) & (w.name # "") THEN (* File name found. *)
			GetSubsysDirByLocator(w.loc, dir);
			(* Call the OfrontBrowser.ShowDef with the defined work paths: *)
			OfrontOPM.SetWorkDir(dir, dir, TRUE, ExistsDir(dir, "Sym"), "");
			OfrontBrowser.ShowDef;
		END;
	END;
END ShowDef;

BEGIN
	rootDir := Files.dir.This("")(HostFiles.Locator).path$;
	IF XDevMisc.SetCurrentDir(rootDir) THEN END;
	XDevMisc.SetEnv("XDev", rootDir)
END XDevCmd.